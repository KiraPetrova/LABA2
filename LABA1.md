## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2401`

#### Выполнилa: `Петрова Кира Денисовна`

#### Вариант: `20`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

> Напишите программу на Java, которая выполняет следующие действия
с одномерным массивом натуральных чисел:
1)Считывает с консоли число N , затем N целых чисел и заполняет
   массив размером N .
2)Размещает числа в массиве таким образом, чтобы числа, являю-
   щиеся числами Фибоначчи, находились в начале массива в порядке
   возрастания, а остальные числа — в конце массива в порядке убы-
   вания. Число является числом Фибоначчи, если оно присутствует
   в последовательности Фибоначчи.
3)Находит и выводит количество чисел Фибоначчи в массиве.
4)Выводит элементы массива, заменяя числа Фибоначчи на порядко-
   вый номер в последовательности, а остальные числа — на −1.
5)Заменяет каждое число в массиве на сумму его чётных цифр и
   выводит полученный массив.

Данную задачу можно разделить на 6 подзадач:

- 1 подзадача включает в себя 3 пункта:
  1. Нахождение числа Фибоначчи
  2. Постановка найденного числа в начало массива
- 2 подзадача является сортировкой по возрастанию методом "Пузырька" для чисел Фибоначчи
- 3 подзадача является сортировкой по возрастанию с конца (т.е. по убыванию) методом "Пузырька" для чисел, не являющимися числами Фибоначчи:
- 4 подзадача включает в себя подсчет чисел Фибоначчи
- 5 подзадача включает в себя 2 пункта:
  1. Замену чисел Фибоначчи на их порядковый номер
  2. Замену оставшихся чисел на "-1"
- 6 подзадача включает в себя замену каждого элемента массива на сумму его четных цифр

### 2. Входные и выходные данные

#### Данные на вход

На вход программа должна получить 1 число (N), длину массива, при этом мы понимаем, что оно должно быть натуральным, чтобы массив можно было задать. Также нужно ввести N чисел для заполнения массива, при этом в условии сказано, что они относятся к множеству натуральных чисел. Значит минимальное значение для всех переменных 1, максимальное не дано. Но мы можем взять за максимальное число, например 10^8 степени, т.к. можно предположить, что для обывательского использования программы обычным пользователем превышение лимита не произойдет.

|                   | Тип                         | min значение | max значение |
|-------------------|-----------------------------|--------------|--------------|
| N (Число 1)       | Целое неотрицательное число | 1            | 10^8         |
| Число 2           | Целое неотрицательное число | 1            | 10^8         |
| ...                                                                           |
| Последнее число   | Целое неотрицательное число | 1            | 10^8         |

#### Данные на выход

Программа должна произвести 4 вывода:
- 1) Выводим массив такой, что числа, являющиеся числами Фибоначчи, находились в начале массива в порядке возрастания, а остальные числа — в конце массива в порядке убывания. Значения от 0 до 10^8.(количество N)
- 2) Выводим количество чисел Фибоначчи (число от 0 до N)
- 3) Выводим элементы массива, заменяя числа Фибоначчи на порядковый номер в последовательности, а остальные числа — на −1. Значения от -1 до N-1.(количество N)
- 4) Выводим массив такой, в котором заменены каждые числа на сумму их чётных цифр. Значения от 0 до 8*10^8.(количество N)

|          | Тип                          | количество элементов | min значения элементов | max значения элементов |
|----------|------------------------------|----------------------|------------------------|------------------------|
| Массив 1 | Одномерный массив            | N                    | 0                      |    10^8                |
| Число 1  | Целое неотрицательное число  | 1                    | 0                      |    N                   |
| Массив 2 | Одномерный массив            | N                    | -1                     |    N-1                 |
| Массив 3 | Одномерный массив            | N                    | 0                      |    8*10^8              |

### 3. Выбор структуры данных

Программа получает 1 натуральное число (N) и еще N натуральных чисел. Поэтому для их хранения
можно выделить 1 переменную (`N`) типа `int` и 2 переменную `a` типа `int[]`.

|              | название переменной | Тип (в Java) | 
|--------------|---------------------|--------------|
| 1 переменная | `N`                 | `int`        |
| 2 переменная | `a`                 | `int[]`      |

Для вывода результата нужно завести переменную 1 типа `int` для хранения целого неотрицательного числа. А для остальных выводов необязательно заводить новые переменные, тк мы будем просто изменять исходный массив `a` и его выводить.

|              | название переменной | Тип (в Java) | 
|--------------|---------------------|--------------|
| 1 переменная | `count`             | `int`        |
| 2 переменная | `a`                 | `int[]`      |
### 4. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает 1 натуральное число, обозначенные как `N`. Затем считывает еще N натуральных чисел, параллельно заполняя массив `a`.

2. **1 подпрограмма:**  
   **a)** Программа бежит по массиву, для текущего элемента создает цикл while. В нем мы генерируем ближайшее к элементу число Фибоначчи.
   **b)** Программа сравнивает найденное число Фибоначчи с текущим элементом и если они совпадают, то меняет местами значения текущего элемента и элемента из начала массива, в которое мы еще не заменили.
3. **2 подпрограмма:**
   Выполняет сортировку методом "Пузырька". В данном методе с помощью цикла for и вложенного в него еще одного цикла for мы реализуем программу, где при первом проходе (у нас возрастание) мы ставим на место наибольший элемент, при втором проходе второй наибольший и тд. С помощью того, что мы правильно реализуем вложенный цикл, мы пробегаемся по массиву не сравнивая каждый раз все элементы, а каждый раз сравниваем элементы без предыдущего наибольшего, что сокращает количество операций примерно вдвое.
4. **3 подпрограмма:**
   Выполняет сортировку методом "Пузырька" только в порядке убывания. (про метод см. пункт 3)
5. **Вывод результата:**  
   На экран выводится массив, состоящий из натуральных чисел.
6. **4 подпрограмма:**
   Выполняет нахождение чисел Фибоначчи (см. пункт 1) и их подсчет.
7. **Вывод результата:** На экран выводится целое неотрицательное число.
8. **5 подпрограмма:** Бежим по массиву и, используя найденное ранее количество чисел Фибоначчи выводим либо номер элемента, либо -1.
9. **Вывод результата:** На экран выводится массив, состоящий из чисел в пределах от -1 до N-1.
10. **6 подпрограмма:** Бежим по массиву и подсчитывает для каждого элемента сумму его четных цифр.
11. **Вывод результата:** На экран выводится массив, состоящий из целых неотрицательных чисел.




### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;
public class lab2 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        out.print("Введите число N (длину массива)"); // Выводим на экран фразу для ввода с клавиатуры
        int N = in.nextInt(); // Присваиваем целочисленной переменной X введенное с клавиатуры значение

        int[] a = new int[N]; // Создаем одномерный массив a для типа данных int

        out.print("Введите N чисел через пробел (элементы массива)"); // Выводим на экран фразу для ввода с клавиатуры
        for (int i = 0; i < a.length; i++) { // Бежим по массиву a
            a[i] = in.nextInt(); // Присваиваем ячейкам массива введенные с клавиатуры значения
        }

        int k = 0; // Присваиваем целочисленной переменной k значение 0 (нужна для подстановки в начало массива в дальнбежейшей подпрограмме)

        for (int i = 0; i < a.length; i++) { // Бежим по массиву a
            int a1 = 1; // Присваиваем целочисленной переменной a1 значение 1 (1 число из последовательности Фибоначчи)
            int a2 = 1; // Присваиваем целочисленной переменной a2 значение 1 (2 число из последовательности Фибоначчи)
            int s = 0; // Присваиваем целочисленной переменной s значение 0 (переменная для числа Фибоначчи)
            while (s < a[i]) { // Заводим цикл while в котором будем увеличивать переменную s, чтобы получить ближайшее число Фибоначчи к текущей переменной из списка
                s = a1 + a2; // Увеличиваем переменную s
                a1 = a2; // Присваиваем переменной a1 значение переменной a2
                a2 = s; // Присваиваем переменной a1 значение переменной s
            }
            if ((s == a[i] || a[i] == 1) && s != 0) {  // Проверяем является ли полученное ближайшее число Фибоначчи к текущей переменной из списка самим этим элементом
                int d = a[k];  // Присваиваем целочисленной переменной d значение переменной a[k] (то есть значение первого элемента из списка)
                a[k] = a[i];  // Присваиваем переменной a[k] значение переменной a[i] (найденное число Фибоначчи)
                a[i] = d;  // Присваиваем переменной a[i] значение переменной d (можно сказать, что мы просто меняем местами значения этих переменных)
                k++;  // Увеличиваем счетчик k
            }
        }

        // Сортировка методом "Пузырька" по возрастанию (для чисел Фибоначчи)
        for (int j = 1; j < k; j++) { // Заводим цикл for для j, чтобы шла проверка без предыдущего найденного наибольшего элемента
            for (int i = 0; i < k - j; i++) { // Заводим цикл for для i, чтобы шла проверка без предыдущего найденного наибольшего элемента
                if (a[i] > a[i + 1]) { // Заводим условие "Если текущий элемент массива больше следующего"
                    int z = a[i]; // Присваиваем переменной z значение переменной a[i]
                    a[i] = a[i + 1]; // Присваиваем переменной a[i] значение переменной a[i+1]
                    a[i + 1] = z; // Присваиваем переменной a[i+1] значение переменной z
                }
            }
        }

        // Сортировка методом "Пузырька" по возрастанию с конца (для чисел, не входящих в последовательность Фибоначчи)
        for (int j = 1; j < a.length; j++) { // Заводим цикл for для j, чтобы шла проверка без предыдущего найденного наибольшего элемента
            for (int i = k; i < a.length - j; i++) { // Заводим цикл for для i, чтобы шла проверка без предыдущего найденного наибольшего элемента
                if (a[i] < a[i + 1]) { // Заводим условие "Если текущий элемент массива больше следующего"
                    int z = a[i]; // Присваиваем переменной z значение переменной a[i]
                    a[i] = a[i + 1]; // Присваиваем переменной a[i] значение переменной a[i+1]
                    a[i + 1] = z; // Присваиваем переменной a[i+1] значение переменной z
                }
            }
        }

        for (int i = 0; i < a.length; i++) { // Бежим по массиву a
            out.print(a[i] + " "); // Выводим текущее значение элемента массива
        }
        out.println(); // Переход на новую строчку для вывода ответа на следующий пункт задания


        int count = 0; // Присваиваем целочисленной переменной k значение 0 (будем подсчитывать количество чисел Фибоначчи)

        for (int i = 0; i < a.length; i++) { // Бежим по массиву a
            int a1 = 1; // Присваиваем целочисленной переменной a1 значение 1 (1 число из последовательности Фибоначчи)
            int a2 = 1; // Присваиваем целочисленной переменной a2 значение 1 (2 число из последовательности Фибоначчи)
            int s = 0; // Присваиваем целочисленной переменной s значение 0 (переменная для числа Фибоначчи)
            while (s < a[i]) { // Заводим цикл while в котором будем увеличивать переменную s, чтобы получить ближайшее число Фибоначчи к текущей переменной из списка
                s = a1 + a2; // Увеличиваем переменную s
                a1 = a2; // Присваиваем переменной a1 значение переменной a2
                a2 = s; // Присваиваем переменной a1 значение переменной s
            }
            if ((s == a[i] || a[i] == 1) && s != 0) {  // Проверяем является ли полученное ближайшее число Фибоначчи к текущей переменной из списка самим этим элементом
                count++;  // Увеличиваем счетчик k
            }
        }

        out.println(count); // Выводим переменную k (количество чисел Фибоначчи)


        for (int i = 0; i < a.length; i++) { // Бежим по массиву a
            if (i < count) { // Заводим условие "Если номер текущего элемента массива меньше количества чисел Фибоначчи" (то есть что номер элемента это номер элемента, значение которого является числом Фибоначчи)
                out.print(i); // Выводим номер элемента массива
            } else {  // Иначе
                out.print(-1);  // Выводим "-1"
            }
        }
        out.println(); // Переход на новую строчку для вывода ответа на следующий пункт задания


        for (int i = 0; i < a.length; i++) { // Бежим по массиву a
            int su = 0; // Присваиваем целочисленной переменной su значение 0 (будем подсчитывать сумму четных цифр текущего элемента)
            while (a[i] > 0) { // Заводим цикл while, чтобы шла проверка, что текущий элемент массива больше 0
                if ((a[i] % 10) % 2 == 0) { // Заводим условие if "Если последняя цифра текущего элемента массива четная"
                    su += a[i] % 10; // Прибавляем в значение переменной su последнюю цифру
                } else { // Иначе
                    su += 0; // Прибавляем в значение переменной su 0 (нейтральный элемент к сложению)
                }
                a[i] = a[i] / 10; // Присваиваем текущей переменной значение ее же, но без последней цифры
            }
            a[i] = su; // Присваиваем текущей переменной значение su
        }
        for (int i = 0; i < a.length; i++) { // Бежим по массиву a
            out.print(a[i] + " "); // Выводим текущее значение элемента массива
        }
    }
}
```

### 6. Анализ правильности решения

Программа работает корректно. Покажем это на нескольких различных примерах. Когда чисел Фибоначчи в массиве нет, когда массив весь состоит из них и когда есть и числа Фибоначчи и числа, не являющиеся числами Фибоначчи.

1. Тест при `N`==5 и 0 чисел Фибоначчи:

    - **Input**:
        ```
        5
        4 35 9 88 14
        ```

    - **Output**:
        ```
        88 35 14 9 4 
        0
        -1-1-1-1-1
        16 0 4 0 4
        ```

2. Тест при `N`==5 и 5 чисел Фибоначчи:

    - **Input**:
        ```
        5
        8 2 13 55 1
        ```

    - **Output**:
        ```
        1 2 8 13 55 
        5
        01234
        0 2 8 0 0
        ```

3. Тест при `N`==5 и 3 числа Фибоначчи:

    - **Input**:
        ```
        5
        610 4 8 144 6
        ```

    - **Output**:
        ```
        8 144 610 6 4 
        3
        012-1-1
        8 8 6 6 4
        ```